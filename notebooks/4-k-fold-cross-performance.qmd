---
title: 10-fold Development and Cross-Validation
---

```{r}
source("notebooks/initialize-data-analysis.r", local = TRUE)
```

```{r}
library(BAS)
library(rsample) # for vfold_cv()
library(furrr) # for future_map()
library(tidymodels)
library(CalibrationCurves)

data_patient_fold_prep <- data_patient_complete |>
  select(all_of(predictor_list), flag_ADR_TP_ID)

fold_samples <- vfold_cv(data_patient_fold_prep, v = 10, repeats = 3)

run_bas_glm <- function(data, formula, family, ...) {
  bas.glm(formula, data = data, family = family, ...)
}

extract_variable_names <- function(sample) {
  data <- analysis(sample)
  model <- data |>
    run_bas_glm(
      formula = flag_ADR_TP_ID ~ .,
      family = binomial(),
      MCMC.iterations = 100000,
      method = "MCMC"
    )
  variable.names(predict(model, estimator = "HPM"))[-1] |>
    str_extract(paste(predictor_list, collapse = "|"))
}

# Function to modify sample data and fit model
fit_model_to_sample <- function(sample, variables) {
  data <- analysis(sample) |>
    mutate(flag_ADR_TP_ID = as.factor(flag_ADR_TP_ID))

  formula <- reformulate(termlabels = variables, response = "flag_ADR_TP_ID")

  logistic_reg() |>
    set_engine("glm") |>
    set_mode("classification") |>
    fit(formula, data = data)
}

calc_fold_performance <- function(sample, model) {
  data <- assessment(sample)
  pHat <- predict(model$fit, data, type = "response")
  yTest <- data$flag_ADR_TP_ID
  calperf <- valProbggplot(pHat, yTest, smooth = "none")

  tibble(
    fold_C_index = calperf$Cindex[[1]],
    fold_calibration_intercept = calperf$Calibration$Intercept[[1]],
    fold_calibration_slope = calperf$Calibration$Slope[[1]]
  )
}

# Set up future to use multiple cores
plan(multisession, workers = parallel::detectCores() - 2)

fold_predict_HPM <- fold_samples$splits |>
  future_map(extract_variable_names, .options = furrr_options(seed = TRUE))

# Fit model to each sample in parallel
fold_full <- future_map2(fold_samples$splits, fold_predict_HPM, fit_model_to_sample)

fold_estimates <- future_map2_dfr(fold_samples$splits, fold_full, calc_fold_performance)

plan(sequential)
```

```{r}
fold_performance_metrics <- fold_estimates |>
  summarise(
    mean_fold_C_index = mean(fold_C_index),
    mean_fold_calibration_intercept = mean(fold_calibration_intercept),
    mean_fold_calibration_slope = mean(fold_calibration_slope)
  )
```

```{r}
save(fold_performance_metrics, file = "data/model-performance/fold-performance-metrics.rda")
```